# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
name: Build and deploy Node.js app to Azure Web App - taxcredit-visual

on:
  push:
    branches:
      - master
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      PUBLISHPROFILE: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'

      - name: Install dependencies and build
        run: |
          npm install
          npm run build
          
          # Check if build directory exists and has content
          if [ ! -d "build" ] || [ -z "$(ls -A build)" ]; then
            echo "::error::Build directory is empty or does not exist. Build may have failed."
            exit 1
          fi
          echo "Build completed successfully. Content verified in build directory."

      - name: Run tests (optional)
        run: echo "No tests configured. Skipping..."

      - name: Create web.config file
        run: |
          echo '<?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <system.webServer>
              <rewrite>
                <rules>
                  <rule name="React Routes" stopProcessing="true">
                    <match url=".*" />
                    <conditions logicalGrouping="MatchAll">
                      <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
                      <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
                      <add input="{REQUEST_URI}" pattern="^/(api)" negate="true" />
                    </conditions>
                    <action type="Rewrite" url="/" />
                  </rule>
                </rules>
              </rewrite>
              <staticContent>
                <mimeMap fileExtension=".json" mimeType="application/json" />
                <mimeMap fileExtension=".woff" mimeType="application/font-woff" />
                <mimeMap fileExtension=".woff2" mimeType="application/font-woff2" />
              </staticContent>
            </system.webServer>
          </configuration>' > build/web.config

      - name: Create health endpoint for Azure App Service
        run: |
          echo "OK" > build/health
          # health.html 파일은 public 폴더에서 자동으로 build 폴더로 복사됩니다.

      - name: Create staticwebapp.config.json for SPA routing
        run: |
          echo '{
            "navigationFallback": {
              "rewrite": "/index.html",
              "exclude": ["/static/*", "/images/*", "/*.{png,jpg,gif,ico,css,js}"]
            },
            "routes": [
              {
                "route": "/health",
                "serve": "/health.html"
              },
              {
                "route": "/*",
                "serve": "/index.html",
                "statusCode": 200
              }
            ]
          }' > build/staticwebapp.config.json

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: 'bbd4460e-5bbf-4ab6-ae25-ce532a24f6ab'
          allow-no-subscriptions: true

      - name: Verify build content before deployment
        run: |
          echo "Checking build directory content before deployment..."
          find build -type f | sort
          echo "Total files in build directory: $(find build -type f | wc -l)"
          echo "Content of index.html:"
          cat build/index.html | head -20
          
          # deploy.zip이 있으면 제거 (불필요한 파일 정리)
          if [ -f "deploy.zip" ]; then
            echo "🔄 Removing unnecessary deploy.zip file"
            rm -f deploy.zip
          fi
          
          # build.zip 명시적 생성 - build/ 폴더 내용만 루트에 압축
          echo "🔄 Creating build.zip with the correct structure..."
          cd build && zip -r ../build.zip * && cd ..
          
          # zip 파일 존재 검증
          if [ ! -f "build.zip" ]; then
            echo "::error::build.zip file was not created. Deployment will fail."
            exit 1
          fi
          
          # zip 파일 크기 검증
          ZIP_SIZE_BYTES=$(du -b build.zip | cut -f1)
          if [ "$ZIP_SIZE_BYTES" -lt 1000 ]; then
            echo "::error::build.zip is too small (${ZIP_SIZE_BYTES} bytes). The compression likely failed."
            exit 1
          fi
          
          echo "✅ Build content verified and archived for deployment."
          echo "build.zip details:"
          du -h build.zip
          echo "Verifying ZIP file contents..."
          unzip -l build.zip | head -10

      - name: Strict ZIP structure verification
        run: |
          echo "Running strict ZIP structure verification..."
          
          # 중요 파일들이 루트에 직접 있는지 확인
          echo "Checking zip file structure..."
          if unzip -l build.zip | grep -q "build/"; then
            echo "::error::ZIP file contains nested 'build/' directory. The structure is incorrect."
            echo "Current ZIP structure (showing nested paths):"
            unzip -l build.zip | grep "build/"
            exit 1
          fi
          
          # 핵심 파일들 루트 레벨 검증
          echo "Checking for essential files at the root level..."
          MISSING_FILES=0
          
          if ! unzip -l build.zip | grep -q "index.html"; then
            echo "::error::index.html not found at zip root"
            MISSING_FILES=$((MISSING_FILES+1))
          else
            echo "✅ index.html found at zip root"
          fi
          
          if ! unzip -l build.zip | grep -q "static/"; then
            echo "::error::static/ directory not found at zip root"
            MISSING_FILES=$((MISSING_FILES+1))
          else
            echo "✅ static/ directory found at zip root"
          fi
          
          if ! unzip -l build.zip | grep -q "favicon.ico"; then
            echo "::warning::favicon.ico not found at zip root"
          else
            echo "✅ favicon.ico found at zip root"
          fi
          
          if [ $MISSING_FILES -gt 0 ]; then
            echo "::error::ZIP file is missing $MISSING_FILES essential files at root level"
            exit 1
          fi
          
          echo "✅ ZIP structure verification passed! The build.zip file is ready for deployment."

      - name: Manual deployment using Kudu API
        run: |
          echo "Extracting credentials from publish profile..."
          # PublishProfile을 환경변수로 받아 파일로 저장 후 파싱
          echo "$PUBLISHPROFILE" > publishprofile.xml
          
          # 파일 생성 확인 로그 추가
          if [ -s publishprofile.xml ]; then
            echo "✅ publishprofile.xml 파일이 성공적으로 생성되었습니다."
            PROFILESIZE=$(du -h publishprofile.xml | cut -f1)
            echo "파일 크기: $PROFILESIZE"
          else
            echo "⚠️ publishprofile.xml 파일이 비어 있거나 생성되지 않았습니다."
            echo "::error::PublishProfile 파일 생성 실패. 배포가 중단됩니다."
            exit 1
          fi
          
          # 파일에서 정보 추출
          PUBLISH_URL_RAW=$(grep 'publishUrl=' publishprofile.xml | head -n1 | grep -o 'publishUrl="[^"]*"' | cut -d'"' -f2)
          echo "Raw publishUrl: $PUBLISH_URL_RAW"
          
          # URL 파싱 개선 - 도메인 부분만 정확히 추출
          if [[ $PUBLISH_URL_RAW == *"://"* ]]; then
            # URL에 프로토콜이 포함된 경우
            KUDU_DOMAIN=$(echo "$PUBLISH_URL_RAW" | sed -E 's|^https?://||' | sed 's|:443||' | sed 's|/$||')
          else
            # URL에 프로토콜이 없는 경우
            KUDU_DOMAIN=$(echo "$PUBLISH_URL_RAW" | sed 's|:443||' | sed 's|/$||')
          fi
          
          # 최종 Kudu API URL 구성
          KUDU_API_URL="https://${KUDU_DOMAIN}/api/zipdeploy"
          echo "Processed Kudu domain: $KUDU_DOMAIN"
          echo "Final Kudu API URL: $KUDU_API_URL"
          
          # URL 형식 검증 - scm 호스트 이름이 맞는지 확인
          if [[ ! "$KUDU_DOMAIN" =~ \.scm\.azurewebsites\.net$ ]]; then
            echo "::error::Kudu 도메인이 예상 형식(*.scm.azurewebsites.net)과 일치하지 않습니다: $KUDU_DOMAIN"
            echo "publishprofile.xml에서 추출된 문자열 확인:"
            grep -n 'publishUrl=' publishprofile.xml
            exit 1
          fi
          
          # URL 형식 검증 - 최종 URL이 유효한지 확인
          if [[ ! "$KUDU_API_URL" =~ ^https://[^/]+\.scm\.azurewebsites\.net/api/zipdeploy$ ]]; then
            echo "::error::최종 Kudu API URL이 예상 형식과 일치하지 않습니다: $KUDU_API_URL"
            exit 1
          fi
          
          USERNAME=$(grep 'userName=' publishprofile.xml | head -n1 | grep -o 'userName="[^"]*"' | cut -d'"' -f2)
          PASSWORD=$(grep 'userPWD=' publishprofile.xml | head -n1 | grep -o 'userPWD="[^"]*"' | cut -d'"' -f2)
          
          # 파싱 결과 검증
          if [ -z "$PUBLISH_URL_RAW" ] || [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            echo "⚠️ PublishProfile에서 필요한 정보를 추출하지 못했습니다."
            echo "::error::PublishProfile 파싱 실패. 배포가 중단됩니다."
            exit 1
          fi
          
          # 보안을 위해 임시 파일 삭제
          rm -f publishprofile.xml
          echo "✅ 민감한 정보가 포함된 임시 파일이 삭제되었습니다."
          
          echo "Preparing for ZIP deployment via Kudu API..."
          ZIP_SIZE=$(du -h build.zip | cut -f1)
          ZIP_BYTES=$(du -b build.zip | cut -f1)
          echo "ZIP file size: $ZIP_SIZE ($ZIP_BYTES bytes)"
          echo "ZIP file contents (first 10 entries):"
          unzip -l build.zip | head -10
          
          echo "===== Running ZIP deployment via Kudu API ====="
          # curl 명령 수정 - URL 변수 참조 방식 변경
          HTTP_CODE=$(curl --output response.txt --write-out "%{http_code}" --silent --show-error \
            -X POST "$KUDU_API_URL" \
            -u "$USERNAME:$PASSWORD" \
            -H "Content-Type: application/zip" \
            --data-binary @build.zip)
          
          CURL_EXIT_CODE=$?
          echo "curl exit code: $CURL_EXIT_CODE"
          echo "HTTP response code: $HTTP_CODE"
          
          echo "Response body (first 50 lines):"
          if [ -s response.txt ]; then
            cat response.txt | head -50
          else
            echo "(Empty response body)"
          fi
          
          # curl exit code 분석
          if [ $CURL_EXIT_CODE -ne 0 ]; then
            echo "curl error code $CURL_EXIT_CODE 의미:"
            case $CURL_EXIT_CODE in
              1) echo "Unsupported protocol" ;;
              3) echo "URL malformed" ;;
              5) echo "Couldn't resolve proxy" ;;
              6) echo "Couldn't resolve host" ;;
              7) echo "Failed to connect to host" ;;
              22) echo "HTTP page not retrieved" ;;
              26) echo "Read error" ;;
              27) echo "Out of memory" ;;
              28) echo "Operation timeout" ;;
              35) echo "SSL connect error" ;;
              47) echo "Too many redirects" ;;
              51) echo "The peer certificate cannot be authenticated with known CA certificates" ;;
              52) echo "The server didn't reply anything" ;;
              53) echo "SSL crypto engine not found" ;;
              *) echo "Unknown curl error" ;;
            esac
            echo "::warning::cURL failed with exit code $CURL_EXIT_CODE"
          fi
          
          # HTTP 상태 코드 분석
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "✅ Deployment successful with HTTP status code: $HTTP_CODE"
          else
            echo "⚠️ Deployment may have failed. HTTP status code: $HTTP_CODE"
            echo "::warning::Deployment via Kudu API returned unexpected HTTP code: $HTTP_CODE"
          fi
          
          echo "Waiting for deployment to complete and files to be accessible..."
          sleep 60
          
          echo "Verifying deployment..."
          # 디렉토리 조회 명령 URL도 변수 참조 방식 변경
          # 최종 Kudu API URL에서 디렉토리 경로로 수정
          KUDU_VFS_URL="https://${KUDU_DOMAIN}/api/vfs/site/wwwroot/"
          echo "Kudu VFS URL: $KUDU_VFS_URL"
          
          LIST_CODE=$(curl --output wwwroot_listing.txt --write-out "%{http_code}" --silent --show-error \
            "$KUDU_VFS_URL" \
            -u "$USERNAME:$PASSWORD" \
            -H "Accept: application/json")
          
          LIST_EXIT_CODE=$?
          echo "curl exit code for directory listing: $LIST_EXIT_CODE"
          echo "HTTP response code for directory listing: $LIST_CODE"
          
          if [ $LIST_EXIT_CODE -ne 0 ]; then
            echo "⚠️ Failed to list directory. curl exit code: $LIST_EXIT_CODE"
            echo "::warning::Directory listing failed with curl exit code $LIST_EXIT_CODE"
          elif [ "$LIST_CODE" -ge 200 ] && [ "$LIST_CODE" -lt 300 ]; then
            echo "✅ Successfully retrieved wwwroot directory listing"
            echo "Files in /site/wwwroot (JSON raw response, first 10 lines):"
            cat wwwroot_listing.txt | head -10
            echo "Extracted file names:"
            cat wwwroot_listing.txt | grep -o '"name":"[^"]*"' | cut -d'"' -f4 | sort
            
            # 특정 필수 파일 확인
            if cat wwwroot_listing.txt | grep -q '"name":"index.html"'; then
              echo "✅ index.html found in wwwroot"
            else
              echo "⚠️ index.html NOT found in wwwroot"
              echo "::warning::index.html not found in wwwroot. Deployment may have failed."
            fi
            
            if cat wwwroot_listing.txt | grep -q '"name":"static"'; then
              echo "✅ static directory found in wwwroot"
            else
              echo "⚠️ static directory NOT found in wwwroot"
              echo "::warning::static directory not found in wwwroot. Deployment may have failed."
            fi
          else
            echo "⚠️ Failed to retrieve wwwroot directory listing. HTTP status code: $LIST_CODE"
            echo "Response:"
            cat wwwroot_listing.txt
            echo "::warning::Failed to verify deployment content in wwwroot. HTTP code: $LIST_CODE"
          fi

      - name: Verify deployment
        run: |
          echo "Deployment completed, waiting for 30 seconds for the app to be available..."
          sleep 30
          
          # Check if the app is accessible
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://taxcredit-visual.azurewebsites.net/health)
          echo "Health endpoint status: $HTTP_STATUS"
          
          # Additional checks for static resources
          INDEX_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://taxcredit-visual.azurewebsites.net/index.html)
          echo "Index.html status: $INDEX_STATUS"
          
          STATIC_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://taxcredit-visual.azurewebsites.net/static)
          echo "Static directory status: $STATIC_STATUS"
          
          if [ "$HTTP_STATUS" == "200" ] && [ "$INDEX_STATUS" == "200" ]; then
            echo "✅ Deployment successful! App is accessible."
          else
            echo "⚠️ App might not be fully accessible yet. Please check manually."
            echo "::warning::App deployment validation didn't fully pass. Manual verification recommended."
          fi

      - name: Deployment summary
        run: |
          echo "## 📊 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "* **Application:** taxcredit-visual" >> $GITHUB_STEP_SUMMARY
          echo "* **Deployment time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "* **URL:** https://taxcredit-visual.azurewebsites.net" >> $GITHUB_STEP_SUMMARY
