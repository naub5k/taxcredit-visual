# 📊 API 속도점검 토론 (2025-05-25)

## 🧠 토론 주제 요약
- 샘플 데이터: Azure DB의 `insu_sample` 테이블
- 실전 데이터: Azure DB의 `insu_clean` 테이블  
- Raw 데이터: Azure DB의 `insu_clean_Raw` 테이블
- 목표: 앱 반응속도 테스트 및 최적화

## 📄 페이지 구성 현황

현재 토론 문서는 **속도/렌더링 문제에 대한 단일 흐름**으로 진행 중이며,
다음과 같은 **블럭 기준 페이지 구획**으로 정리됩니다:

---

#### 1. `🧠 토론 주제 요약`
- 전체 회의 출발점
- 대상 테이블 / 환경 구성 정리

#### 2. `🗣 GPT 의견` / `🧪 커서 분석`
- 번갈아 가며 기록
- 중간 질문 블럭 `🔁 질문 / 쟁점` 포함

#### 3. `📌 실행 테스트 기록`
- 실제 브라우저나 API 호출로 확인한 내용
- 응답 속도(ms), 화면 상태, 콘솔 에러 등

#### 4. `🛠 해결 제안 / 구조 리팩토링`
- 변경 구조 제안
- 코어 구조 변경 논의

#### 5. `✅ 결론 / 추후 작업 연결`
- 최종 정리 및 요청서로 이어질 내용

---

## 🗣 현재 앱 구조 분석

### 기존 구조 및 문제점
- 클라이언트(웹앱)는 `RegionDetailPage.js`에서 `getSampleList` 함수를 통해 데이터 호출
- API 연결: Azure Function App(`taxcredit-api-func-v2`)
- 데이터 조회: `insu_sample` 또는 `insu_clean` 테이블
- 문제점:
  - 응답 데이터 크기: 최대 1.4MB (34,000건 이상)
  - 초기 렌더링: `Math.max(...spread)` 호출로 stack overflow 발생
  - F5 재호출: 응답 속도는 개선되었으나 렌더링 오류로 화면 미표시

## 🔁 핵심 쟁점

1. **최적화 우선순위**
   - Azure Function 응답 시간 최적화 vs. 클라이언트 데이터 처리 구조 개선
   
2. **데이터 제한 방식**
   - 최대 응답 크기/필드 제한
   - 서버 측 `TOP N` 쿼리 적용 가능성
   
3. **코드 리팩토링**
   - `RegionDetailPage.js`의 `maxEmployeeCount` 계산 구조 개선

## 🧩 페이지네이션 구조 도입 제안

현재 렌더링 방식은 전체 데이터를 한 번에 불러와 **스크롤로 모든 항목을 연속 렌더링**하는 구조입니다.

이로 인한 문제점:
- `34,000건 이상` 데이터를 한 페이지에서 모두 처리
- `Math.max(...array)`에서 스택 초과
- UI 성능 저하 및 사용자 경험 악화

## 🛠 구조 개선 제안

### 1. 클라이언트 측 페이지네이션
- `filteredData.slice(start, end)` 방식
- URL 파라미터 또는 내부 상태로 페이지 이동 관리

### 2. 서버 측 쿼리 제한
- `OFFSET`, `FETCH NEXT` 등을 활용해 API 호출에서 일부만 응답

### 3. 무한스크롤 형태로 lazy loading
- IntersectionObserver 활용 (비동기식 렌더링)

## 🔄 역제안: 하이브리드 접근 방식

기존 제안들을 보완하는 **하이브리드 데이터 로딩 전략**을 제안합니다:

### 1. 초기 데이터 최소화 (Fast First Load)
- 첫 화면에 필요한 최소 데이터만 빠르게 로드 (20-50건)
- 서버에서 집계 통계는 미리 계산하여 전송 (max, min, avg 등)
- 화면 렌더링에 `Math.max()` 사용 대신 서버 계산값 활용

### 2. 데이터 캐싱 + 점진적 로딩
- IndexedDB를 활용한 로컬 데이터 캐싱
- 백그라운드에서 추가 데이터 청크 로딩 (500-1000건 단위)
- 사용자 동작 예측 기반 선제적 데이터 로딩

### 3. 가상 스크롤 + 서버 데이터 페이징 결합
- React-Window 또는 React-Virtualized 활용
- 화면에 보이는 요소만 렌더링 (메모리 사용량 최소화)
- 서버와 동기화된 페이지 상태 관리

### 4. 성능 측정 및 자동 최적화
- 응답 시간, 메모리 사용량, 렌더링 성능 실시간 측정
- 사용자 환경에 따른 로딩 전략 자동 조정

## ⚙️ 구현 우선순위

1. 서버 측 집계값 계산 API 추가 (1일)
2. 클라이언트 렌더링 구조 개선 (2일)
3. 가상 스크롤 구현 (1일)
4. 캐싱 및 점진적 로딩 구현 (2일)
5. 성능 측정 도구 추가 (1일)

이 전략은 첫 화면 로딩 속도를 대폭 개선하면서, 전체 데이터 활용도 유지할 수 있는 균형적 접근법입니다.

### 🧠 GPT 평가: 커서의 역제안에 대한 의견

커서가 이번에 작성한 역제안은 **구조적 현실성과 실행 가능성** 면에서 매우 잘 정리되어 있습니다.

---

#### ✅ 강점

1. **단계별 실행 계획이 명확함**
   - 단순 개선이 아닌, 우선순위 기반 로드맵으로 정리됨
   - 예: "서버측 집계값 계산 → 클라이언트 개선 → 가상 스크롤" 흐름이 자연스럽고 타당

2. **기존 구조를 전면 부정하지 않고 보완**
   - 기존 페이지네이션, lazy-loading 전략을 포함하면서도
   - "Fast First Load" + 서버측 집계값 활용 같은 **성능 중심 전략**을 끼워넣음

3. **커서 실행 구조와 잘 연결되는 방식**
   - "1일", "2일" 식 구현 가능 시간까지 언급한 것은  
     커서가 **실제 실행 가능한 구조로 의도했다는 점**에서 의미 있음

---

#### ⚠️ 보완 가능 지점

- 클라이언트 측 로직 중 **React-Virtualized 도입 결정**은  
  현재 구조의 Tailwind 기반 레이아웃과 충돌 가능성 있음 → UI 계층 테스트 필요

- `성능 측정 및 자동 최적화`는 실제 구현 범위가 크므로  
  현재 시점에서는 **개발보다는 구조 추적/로그 기록부터** 단계화하는 것이 좋음

---

#### 📌 결론

커서의 제안은 **실행 타당성 + 전략 균형 + 단계성**을 모두 갖춘 우수한 설계이며,  
현재 유비님이 **진행 전환 지점을 선택하면 요청서로 구체화** 가능합니다.
